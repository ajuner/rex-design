---
id: advanced
title: xform 进阶
---

import * as advancedExamples from 'story/src/xform/2-advanced-examples.stories';

本页主要介绍 xform 的一些进阶用法，包括嵌套的表单数据结构（对象或数组），分形与对应的 model/field API 等。

## 表单片段复用

我们可以利用 `Form.Object` 来实现表单片段的复用。

例如，在下面的家庭信息登记表中，「个人信息」、「父亲」等部分的表单是完全相同的，此时我们可以将这些相同部分抽取到 PersonForm 中，并用 Form.Object 来指定其在上层 model 中的数据字段。

```jsx
function PersonForm({ name, label }) {
  return (
    <div>
      <p>{label}</p>
      <Form.Object name={name}>
        <FormItem name="name" label="姓名" />
        <FormItem name="age" label="年龄" />
        <FormItem name="gender" label="性别" items={['男', '女']} />
      </Form.Object>
    </div>
  );
}

function FamilyForm() {
  return (
    <div>
      <PersonForm name="me" label="个人信息" />
      <PersonForm name="father" label="父亲" />
      <PersonForm name="mother" label="母亲" />
      <PersonForm name="urgency" label="其他紧急联系人" />
    </div>
  );
}
```

<Story fn={advancedExamples.ObjectExample} />

### `Form.Object`

`<Form.Object name={name} />`： 以当前 model 为基础，为其子节点提供一个新的 sub model，并将子节点中的表单值收集到当前 model 中 `name` 对应的位置。

为 Form.Object 设置 `name="&"` 时，可以将当前 model 透传至子节点（相当于没写 Form.Object）。

## 数组类型的数据

我们可以利用 `Form.Array` 来处理数组类型的数据。

例如，在下面的「客户满意度调查列表」中，我们用 Form.Array 包裹了多个 FormItem。

```jsx
<Form.Array name="tickets" layout={arrayCard({ showItemOrder: true })}>
  <FormItem label="客户名称" name="name" />
  <FormItem label="购买日期" name="date" />
  <FormItem label="品牌" name="brand" />
  {/* 其他调查结果表单内容 */}
</Form.Array>
```

<Story fn={advancedExamples.ArrayExample} />

### `Form.Array`

`<Form.Array name={name} itemFactory={itemFactory} layout={layout} />`

Form.Array 会以当前 model 为基础，为其子节点提供一个新的 sub model，并将子节点中的表单值收集到当前 model 中 `{name}.{itemIndex}` 对应的位置。

Form.Array 与 Form.Object 非常类似，但用于处理数组。 注意 Form.Array 为其子节点提供的 sub model 包含两层下标 `{name}.{itemIndex}`： `name` 表示数组所在的字段名称， `itemIndex` 表示数组元素下标。

其他参数：

- `layout` 控制表单如何对数组进行布局，包括数组中每一个元素的布局 以及 相关的操作按钮（添加、删除、上移、下移等）
  - xform 提供一些内置的数组布局，如果不满足你的需求，你也可以在上层实现新的数组布局
- `itemFactory` 用于设置数组中新增元素的初始值

## 处理嵌套数据结构

`Form.Object` 与 `Form.Array` 允许相互嵌套，灵活使用两者，我们可以组合出非常复杂的表单结构。在模型层面， xform 提供了适合「分形」的 API。

通过 `new FormModel(values)` 创建 formModel 之后，我们可以使用 `formModel.getSubModel(name)` 来获取 `name` 对应的子模型 subModel，对 subModel.values 的读写会自动变为对 formModel.values 的读写（背后基于 mobx computed），确保 formModel.values 是整个表单 values 的唯一可信来源。

FormModel（根节点）和 SubModel（子节点）都实现了 [`IModel` interface](api#imodel)，两者拥有几乎相同的方法和属性。大部分情况下，我们不需要区分 FormModel 或 SubModel，而是采用统一的 IModel api 进行开发即可。IModel 提供了 getSubModel 方法，意味着我们可以获取子模型的子模型，甚至是子模型的子模型的子模型…… 在实际进行开发时，我们可以根据情况灵活选取子模型，然后基于子模型进行开发。

(todo 更完善的介绍)

## 主动处理 model 与 field

modelUtils & fieldUtils

当你想要在上层主动对 model 或 field 进行操作时（例如主动触发表单的校验、清空某个字段上的错误等），可以使用 modelUtils / fieldUtils 中的工具方法，具体用法详见 [API](api#modelutilsclearerror).

(TODO 添加自定义表单组件)

## 一个字段对应多个视图

`field.getFork(forkName :string)`

(todo)

## 异步数据源

(todo) makeAsyncValue

## 复杂联动

(todo)

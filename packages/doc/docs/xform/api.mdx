---
id: api
title: API
---

import { Form, FormItem } from '@rexd/xform';

{🚀} 表示进阶 API。 所有 API 都通过 `@rexd/xform` 导出。

## 组件

### `Form`

表单组件，创建所需的上下文，并通过 FormLayout 渲染一个 div：

- FormEnvProvider：表单的环境变量，子组件可以通过 [`useFormEnv`](#useformenv) 获取这些环境变量
- ModelProvider：模型对象，子组件可以通过 [`useModel`](#usemodel) 获取模型对象
- FormLayout： 表单布局

<PropsTable component={Form} />

:::note @alife/hippo-xform
注意因为底层组件库不同，@alife/hippo-xform 提供了不同的 layout 参数。详见 [hippo-xform](hippo-xform).
:::

### `FormItem`

表单项 组件，渲染一个 FormControl，包含项目标签（label）、错误信息、可选的帮助信息，以及具体的控件实例（例如一个输入框）。

<PropsTable
  props={[
    { name: 'component', required: true, type: 'string', description: '组件类型' },
    { name: 'name', required: false, type: 'string', description: '字段数据索引' },
    { name: 'field', required: false, type: 'Field', description: 'Field 对象，提供后将覆盖 name 属性' },
    { name: 'label', required: true, type: 'ReactNode', description: '字段的显示名称' },
    { name: 'tip', type: 'ReactNode', description: '提示信息' },
    { name: 'asterisk', type: 'boolean', description: '是否展示「*」' },
    { name: 'help', type: 'ReactNode', description: '帮助文本' },
    { name: 'fallbackValue', description: '字段值为空时，组件展示用的默认值' },
    { name: 'componentProps', description: '组件的 props' },
    { category: '校验', name: 'required', type: 'boolean', defaultValue: 'false', description: '字段是否必填' },
    {
      category: '校验',
      name: 'requiredMessage',
      type: 'string',
      defaultValue: '"该字段为必填项"',
      description: '必填字段的错误信息',
    },
    {
      category: '校验',
      name: 'validate',
      type: '(value: any, field: Field, trigger: FieldValidateTrigger) => string | Promise<string>',
      // </string> 这个是为了解决 webstorm 的报错 (￣３￣)a
      description: '校验方法。 返回字符串表示字段上的出错信息',
    },
    {
      category: '校验',
      name: 'validateOnMount',
      type: 'boolean',
      description: '组件加载时是否触发校验。 FormEnvProvider 可以指定该 prop 默认值',
      defaultValue: 'false',
    },
    {
      category: '校验',
      name: 'validateOnChange',
      type: 'boolean',
      description: '值修改时是否触发校验。 FormEnvProvider 可以指定该 prop 默认值',
      defaultValue: 'true',
    },
    {
      category: '校验',
      name: 'validateOnBlur',
      type: 'boolean',
      description: '组件失去焦点时是否触发校验。 FormEnvProvider 可以指定该 prop 默认值',
      defaultValue: 'true',
    },
    { name: 'dataSource', description: '同 componentProps.dataSource' },
    { name: 'disabled', description: '同 componentProps.disabled' },
    { name: 'readOnly', description: '同 componentProps.readOnly' },
    {
      name: 'status',
      description: (
        <>
          同 componentProps.status
          <br />
          默认为 undefined；字段校验出错时，status 的默认值为 'error'；
          <br /> <b>注意该 prop 的名称与具体的组件类型相关，例如在 @alife/hippo-xform 中，该 prop 的名称为 'state'</b>
        </>
      ),
    },
    {
      category: '{🚀}',
      name: 'value',
      description: (
        <>
          覆盖表单项默认的 value
          <br />
          <b>注意该 prop 的名称与具体的组件类型相关，例如部分组件该 prop 的名称为 'checked'</b>
        </>
      ),
    },
    { category: '{🚀}', name: 'onChange', description: '覆盖表单项默认的 onChange' },
    { category: '{🚀}', name: 'onBlur', description: '覆盖表单项默认的 onBlur' },
    { category: '{🚀}', name: 'renderPreview', description: '覆盖表单项默认的 预览态渲染方法' },
    {
      category: '{🚀}',
      name: 'isEmpty',
      type: '(value: any) => boolean',
      description: '覆盖表单项默认的判断为空的逻辑',
    },
  ]}
/>

<details>
  <summary>component 列表</summary>

```
"switch"
"checkbox"
"checkboxGroup"
"radioGroup"
"datePicker"
"dateRangePicker"
"timePicker"
"filePicker"
"mediaPicker"
"input"
"textarea"
"numberInput"
"range"
"select"
"singleSelect"
"multiSelect"
"treeSelect"
"singleTreeSelect"
"multiTreeSelect"
"testButtonGroup" (测试用的按钮组，通过 componentProps.items=['A', 'B', 'C'] 设置选项)
```

</details>

:::info @alife/hippo-xform
注意 @alife/hippo-xform 提供了不同的组件类型，详见 [hippo-xform](hippo-xform).
:::

### `Form.Submit`

表单提交[按钮](../button)，点击时...

- 触发所有字段的校验
- 如果校验通过，则调用 `onSubmit(submitValues, model)`
- 如果发生错误，则调用 `onSubmit(erros, model)`

### `Form.Reset`

表单重置[按钮](../button)，点击时将清空 values 与校验错误，然后触发 `onReset`。

### `Form.Effect`

`<Form.Effect watch={watch} effect={effect} fireImmediately={boolean} />`

创建表单联动，每当 watch 对应的值发生变化时，effect 都会被触发。

effect 被触发时，可以获取到两个参数：

- `value: any`: 新的值
- `detail: object`
  - `detail.prev` 旧的值
  - `detail.model` 当前模型
  - `detail.next` 新的值

watch 支持以下用法：

- `string` 监听对应数据索引处 value 变化（注意嵌套字段的变更也会触发 effect）
- [`Feild`](#field) 监听对应 Field 的 value 变化
- [`AsyncValue`](#asyncvalue) 监听对应 asyncValue.current 的 value 变化
- `Array<string | Field | AsyncValue>` 监听多个来源的变化
  - 其中一个来源发生变化时，effect 就会被调用一次
  - effect 触发时，所有来源的值会放在一个数组中
- `() => any` 自定义函数用法，用法同 [mobx reaction](https://mobx.js.org/api.html#reaction) 的第一个参数

[fireImmediately](https://mobx.js.org/reactions.html#fireimmediately-_reaction_) 用于指定是否在首次加载时触发 effect，默认为 false.

### `Form.Array`

[{🚀} 用法](advanced#formarray)。 以当前 model 为基础，为其子节点提供一个新的 sub model，并将子节点中的表单值收集到当前 model 中 `{name}.{itemIndex}` 对应的位置。

<PropsTable
  props={[
    { name: 'name', type: 'string', required: true, description: '字段索引' },
    {
      name: 'layout',
      type: '(input: XFormArrayLayoutInput) => React.ReactElement',
      required: true,
      description:
        '数组布局，控制表单如何对数组进行布局，包括数组中每一个元素的布局 以及 相关的操作按钮（添加、删除、上移、下移等）',
    },
    {
      name: 'itemFactory',
      type: '(arrayModel: SubModel) => any',
      defaultValue: '() => ({})',
      description: '数组中新增元素的初始值, 默认为一个总是返回一个新的空对象的函数',
    },
  ]}
/>

### `Form.Object`

[{🚀} 用法](advanced#formobject)。 以当前 model 为基础，为其子节点提供一个新的 sub model，并将子节点中的表单值收集到当前 model 中 name 对应的位置

<PropsTable props={[{ name: 'name', type: 'string', required: true, description: '字段索引' }]} />

### `Form.ItemGroup`

布局组件，可将多个 FormItem 分为一组。

```jsx
<Form.ItemGroup label="分组名称" inline labelWidth={50} controlWidth={200}>
  <FormItem component="input" />
  <FormItem component="select" />
</Form.ItemGroup>
```

<PropsTable
  props={[
    { name: 'label', type: 'ReactNode', description: '分组的标签' },
    { name: 'inline', type: 'boolean', description: '是否使用内联布局' },
    { name: 'labelWidth', type: 'number | string', description: '分组内 FormItem 的标签宽度' },
    { name: 'controlWidth', type: 'number | string', description: '分组内 FormItem 的控件宽度' },
    { name: 'style', type: 'React.CSSProperties', description: '内联样式' },
    { name: 'className', type: 'string', description: 'className' },
  ]}
/>

### `Form.ItemView`

表单项视图组件。通过 `Form.ItemView` 可以让自定义的组件和普通 FormItem 使用相同的布局。

```jsx
// 普通 FormItem
<FormItem label="标签标签" component="select" />

// 利用 Form.ItemView 让自定义内容使用与 FormItem 相同的布局
<Form.ItemView label="标签标签">
  <MyCustomSelect value={...} onChange={...} />
</Form.ItemView>
```

<PropsTable
  props={[
    { name: 'label', type: 'ReactNode', description: '标签' },
    { name: 'help', type: 'boolean', description: '帮助文本' },
    { name: 'tip', type: 'boolean', description: '提示信息' },
    { name: 'asterisk', type: 'boolean', description: '是否展示「*」' },
    { name: 'error', type: 'boolean', description: '错误信息' },
    { name: 'style', type: 'React.CSSProperties', description: '内联样式' },
    { name: 'className', type: 'string', description: 'className' },
  ]}
/>

## contexts & hooks

### `useModel`

获取当前层级的模型对象。

### `Form.ModelConsumer`

ModelContext 的 [`Consumer`](https://zh-hans.reactjs.org/docs/context.html#contextconsumer)，可用于订阅当前层级的 model。

该组件已经被包裹在 [observer](https://mobx.js.org/react-integration.html) 中，所以你可以在 [render prop](https://zh-hans.reactjs.org/docs/render-props.html) 中读取 mobx observable 对象。

```jsx
<Form.ModelConsumer>
  {(model) => {
    const person = model.getSubModel('person');
    return <span>姓名： {person.getValue('name')}</span>;
  }}
</Form.ModelConsumer>
```

### `Form.ModelProvider`

{🚀} 主动在 react context 中设置模型对象。

`<Form.ModelProvider value={model}>{children}</Form.ModelProvider>`

### `useFormEnv`

{🚀} 获取当前层级的环境变量。

### `FormEnvProvider`

{🚀} 在指定的层级覆盖表单的环境变量。

`<Form />` 渲染时会自动设置环境变量，一般不需要单独使用 `<FormEnvProvider />`。 目前默认支持设置 `isPreview`：

```jsx
<Form>
  <FormItem name="aaa" />
  <FormItem name="bbb" />

  <FormEnvProvider isPreview>
    {/* ccc 和 ddd 总是会处于预览态 */}
    <FormItem name="ccc" />
    <FormItem name="ddd" />
  </FormEnvProvider>
</Form>
```

FormEnvProvider 接受任意的 props，设置后子组件可以通过 `useFormEnv()` 获取到这些环境变量（注意 TypeScript 类型信息要进行相应的拓展）。

设置 FormEnvProvider 时，新的环境变量会与上层的环境变量进行合并，然后传递给子组件。

## 数组布局 {🚀}

需要配合 `Form.Array` 使用

:::info @alife/hippo-xform
注意因为底层组件库不同，@alife/hippo-xform 提供了不同的 layout 参数。详见 [hippo-xform](hippo-xform).
:::

### `arrayCard`

{🚀} 卡片布局

:::note
卡片布局 仍在完善中。
:::

```tsx
interface ArrayCardOptions {
  title?: string;
  showItemCount?: boolean;
  showItemOrder?: boolean;
  style?: React.CSSProperties;
}
```

### `arrayTable`

{🚀} 表格布局

:::note
表格布局 仍在完善中。
:::

```tsx
interface ArrayTableOptions {
  defaultColumnWidth?: number;
  operationColumn?: Partial<Column>;
  orderColumn?: Partial<Column>;
  style?: React.CSSProperties;
  className?: string;
}
```

## 模型与工具

### `IModel`

IModel 用于抽象视图中的一组控件，其对应的数据类型往往是一个对象或一个数组。

IModel 是一个 interface， `FormModel`（根节点）和 `SubModel`（子节点） 实现了该 interface.

- `model.getSubModel(name): SubModel` 获取一个子模型
- `model.getField(name): Field` 获取 name 对应的字段对象
- `model.root: FormModel` 指向根节点 FormModel
- `model.path: string[]` 从 FormModel 到当前 model 的数据路径
- `model.parent: IModel` 指向上一级的 model
- `model.values` 模型上的数据，这是一个 mobx computed 字段
- `model.getValue(name, defaultValue)` 以当前模型为起始路径，读取 name 处的数据
- `model.setValue(name, value)` 以当前模型为起始路径，修改 name 处的数据
- `model.state` 模型级别的状态，这是一个 mobx observable 对象，默认为 `{}`，一般用来管理一些表单的 UI 状态。
- `model.id: string` 模型在所属 FormModel 内的唯一 id

### `Field`

Field 用于抽象视图中的单个控件，其对应的数据类型往往是简单的数字或字符串。

- `field.value` 读取或设置字段的值，这是一个 mobx computed 字段
- `field.state` 字段状态，这是一个 mobx observable 对象，默认为 `{}`。
  - 目前，我们约定了以下属性的含义：
    - `field.state.error` 该字段上的错误消息，当 error 字段有值时，页面中就会展示对应的出错提示
    - `field.state.validating` 是否正在执行校验
    - `field.state.cancelValidation()` 取消上次校验的方法
- `field.config` 字段配置信息，反映该字段对应的控件最近一次被渲染时 React Element 上的 props
- `field.id: string` 字段在所属表单内的唯一 id
- `field.isMounted: boolean` 对应的控件是否渲染在视图中
- `field.path: string[]` 从 FormModel 到该字段的完整路径
- `field.parent: IModel` 指向上一级的 model
- `field.getFork(forkName): Field` 获取 field fork，详见 [相同数据索引对应多个视图](advanced#相同数据索引对应多个视图)
- `field.validate(trigger): Promise<string | undefined>` 执行指定字段上的校验，返回 `Promise<string>` 表示报错信息；trigger 用于指定所要校验触发的来源类型，默认为 `'*'`。
- `field.handleBlur()` 处理控件 blur 事件的回调函数
- `field.handleChange(nextValue: any)` 处理 value 修改的回调函数

### `modelUtils.clearError`

`modelUtils.clearError(model : IModel): void`

mobx action. 清除 model 上所有的错误信息

### `modelUtils.validateAll`

```
modelUtils.validateAll(
  model: IModel,
  trigger?: '*' | 'blur' | 'change'
): Promise<{ hasError: boolean, errors: any }>
```

mobx action. 执行 model 上所有的校验，并返回一个 Promise 表示所有的报错信息；trigger 用于指定所要执行的 validate，默认为 `'*'`。

### `modelUtils.submit`

```
modelUtils.submit(
  model: IModel,
  options?: {
    valueFilter?: 'mounted' | 'all',
    onError?: Function,
    onSubmit?: Function,
  }
): void
```

mobx action. 主动触发 [`Form.Submit`](#formsubmit) 被点击的流程。 options.valueFilter 可以控制 submit 回填哪些值。

### `modelUtils.reset`

```
modelUtils.reset(
  model: IModel,
  options?: {
    onReset?: Function,
  }
): void
```

mobx action. 主动触发 [`Form.Reset`](#formreset) 被点击的流程。

### `createFormItem`

{🚀} `createFormItem(options: FormItemCreationOptions): FormItem`

创建表单项组件。

**用法示例**

```jsx
// 自定义组件
const CitySelect = ({ value, onChange, onBlur }) => {
  return (
    <div>
      <p>请选择居住城市：</p>
      <Select value={value} onChange={onChange} onBlur={onBlur} dataSource={CITY_LIST} />
    </div>
  );
};

// 使用 createFormItem 创建一个自定义 FormItem
const CustomFormItem = createFormItem({
  name: 'myCitySelect',
  component: CitySelect,
  isEmpty(value) {
    return value == null;
  },
  fallbackValue: null,
});

// 像普通 FormItem 一样使用 CustomFormItem
<Form>
  <FormItem component="input" label="姓名" name="name" validate={isValidateName} />
  <CustomFormItem label="城市" name="city" validate={isValidCity} />
</Form>;
```

**类型信息：**

```tsx
export interface FormItemCreationOptions {
  /** 名称 */
  name: string;

  /** 控件对应的 React 组件，例如 `<FormItem component="select" />` 对应 `Select` 组件. */
  component?: React.ComponentType<FormItemComponentProps>;

  /** 控件渲染方法，与 component 参数二选一，优先级高于 component */
  render?(arg: FormItemComponentProps): React.ReactElement;

  /** 组件值的属性名称，默认为 `'value'` */
  valuePropName?: string;

  /** 组件状态值的属性名称，默认为 `'status'` */
  statusPropName?: string;

  /** 预览态下组件的渲染方法。如果不设置该方法，预览态下将使用 render/component 作为后备方案. */
  renderPreview?(props: FormItemComponentProps): React.ReactNode;

  /** 当模型中的字段值为空（undefined）时，渲染控件所使用的值 */
  fallbackValue: any;

  /** 组件类型默认的空值判断方法 */
  isEmpty(value: any): boolean;
}
```

### `FormItem.register`

{🚀} `FormItem.register(options: FormItemCreationOptions): void`

向 FormItem 中注册新的组件。 options 参数类型见上方。 `options.name` 会与已有的组件共享一个命名空间，注意避免冲突。

```jsx
// 自定义组件
const CitySelect = ({ value, onChange, onBlur }) => {
  return (
    <div>
      <p>请选择居住城市：</p>
      <Select value={value} onChange={onChange} onBlur={onBlur} dataSource={CITY_LIST} />
    </div>
  );
};

// 注册
FormItem.register({
  name: 'myCitySelect',
  component: CitySelect,
  isEmpty(value) {
    return value == null;
  },
  fallbackValue: null,
});

// 使用
<FormItem component="myCitySelect" name="city" label="城市" />;
```

### `createAsyncValue`

`createAsyncValue<T>(fetcher: () => Promise<T>, initValue?: T): AsyncValue<T>`

基于 `fetcher` 创建定义一个 AsyncValue，用于声明式地定义异步数据源。

当 `asyncValue.*` (\* 表示 value/status/error) 被订阅时， fetcher 将被首次调用， 其返回结果将作为 `asyncValue.current` 的值。

调用 fetcher 的过程中会进行依赖收集，每当这些依赖的值发生变化时，fetcher 都会被重新触发。

<details>

<summary>具体规则：</summary>

1. 每次 fetcher 被调用时， status 就会变为 loading，并等待 fetcher 返回的 Promise resolve 或 reject；
2. 当 fetcher 返回的 Promise resolve 时， status 变为 ready，同时 current 字段变为最新的值；
3. 当 fetcher 返回的 Promise reject 时， status 变为 error，同时 error 字段记录本次错误；
4. 当 fetcher 返回的 Promise 仍处于 pending 状态时，若 fetcher 再次被调用，已有的 promise 将被忽略，将会回到 1.

</details>

### `AsyncValue`

`AsyncValue` 是一个 interface，该类型的对象通过 [createAsyncValue](#createasyncvalue) 创建。

```tsx
export interface AsyncValue<T> {
  /** 状态，可为以下值 'loading' | 'ready' | 'error' */
  readonly status: AsyncValueStatus;

  /** 当前值 */
  readonly current: T;

  /** 错误 */
  readonly error?: any;

  /** 销毁 AsyncValue */
  dispose(): void;

  /** 重新触发 fetcher */
  refresh(): void;
}
```

#### `isAsyncValue`

`isAsyncValue(obj: object): obj is AsyncValue<any>`

判断一个对象是否为 AsyncValue.

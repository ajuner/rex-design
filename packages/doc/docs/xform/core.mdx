---
id: core
title: xform core
---

xform 表单方案核心部分。

## 动机

mobx 是一个非常优秀的状态管理工具。一是它采用了 Proxy 魔法劫持了所有的状态读取和更新，允许我们用熟悉的 plain Object/Array 方式使用和更新状态；二是 mobx 基于依赖收集实现了组件的精确更新，大部分情况下，即便不进行性能优化，我们也能写出高性能的 React 应用，非常适合中后台大表单场景 —— 渲染组件数量大，但用户一次往往只更新一小部分的表单。

**盒马微应用采用了 mobx 作为应用层的状态管理方案，提供一个能够无缝对接 mobx 模型的表单方案，能够显著提升微应用的研发效率。**

另一方面，大而全的表单方案，其开发成本、维护成本都很高，rex design 作为以组件库为主的技术产品，不应耦合过于复杂的表单方案。我们需要一个拥抱 mobx 的、高性能的、较为精简的表单方案。

所以，xform 作为 rex design 中全新的表单方案，其核心部分的设计思路如下：

- 拥抱 mobx
  - 表单内核采用 mobx 提供的数据结构，无缝对接 mobx 生态（例如 mobx-utils）
  - 精确渲染（只渲染那些必须要渲染的组件），能够承载大表单场景
- 降低上手成本
  - 避免那些解释起来费劲的概念或用法
  - 即使开发者不熟悉 mobx，也能使用该表单方案的大部分功能
  - 表单代码（JSX）、表单视图、表单数据 三者结构相同/相似，缩小「所见」与「所得」的差异
- **简单好用**
  - 灵活的、符合直觉的抽象（Model & Field）
  - 按需生成的内部数据结构，避免用户代码中出现大量的非空判断
- 分形
  - 提升表单代码的可复用性
  - 能够优雅地进行表单套娃

## 双向绑定

通过 `new FormModel(values)` 创建 model，并将 model 传递给视图后，「模型与视图」就会进行双向绑定：

- **视图总是反映模型中的最新值**
- **视图上的操作会直接更新模型**

用户在表单上的交互可以看做是对 model.values 的修改：

```jsx
const model = new FormModel(values);

// 用户在 <input name="foo" /> 中依次输入 abc
model.values.foo = 'a';
model.values.foo = 'ab';
model.values.foo = 'abc';

// 用户在购物车(cart) 中添加了 2瓶快乐水
model.values.cart.items = [];
model.values.cart.items.push({ sku: '快乐水' });
model.values.cart.items.push({ sku: '快乐水' });

// 用户重置了表单
model.values = {};
```

因为空值的存在，`.cart.items` 这样的用法很容易报错，所以 model 提供了 getValue 和 setValue 的方法：

- `model.getValue('foo.bar')` 等价于 `model.values.foo.bar`，但会处理空值情况
- `model.setValue('foo.bar', buzz)` 等价于 `model.values.foo.bar = buzz`，但会处理空值情况（根据数据索引名称会创建新的对象或数组）

## 主动更新模型

我们可以主动对 model.values 进行更新，values 变化后视图会自动更新。

```jsx
// 更新表单传状态
model.values.foo.bar = {
  buzz: [{ hello: 123 }],
};

// 更好的方式是调用 model.setValue 避免空值错误
model.setValue('foo.bar', { buzz: [{ hello: 123 }] });
```

采用这种更新方式，我们可以很方便的实现一个「重置表单」的按钮：

```jsx
import { action } from 'mobx';

<Button
  // 对模型的更新，或者说对 mobx observable 数据的修改，需要放在 mobx action 内
  onClick={action(() => {
    model.values = {};
  })}
>
  重置表单
</Button>;
```

**我们可以认为「用户交互」和「主动更新模型」都是对一个「大对象」（即 model.values）的原地修改，每当这个大对象发生变化时，视图会进行更新以反映大对象的最新值。**

## 监听变化与表单联动

监听变化的能力主要由 [mobx reactions](https://mobx.js.org/reactions.html) 提供。因为 `model.values` 采用了 mobx observable 数据结构，所以开发者可以监听任意粒度/层级数据的变化。

xform 提供了一个适用于表单联动的组件：`<Form.Effect watch={watch} effect={effect} />`。渲染该组件后，当 watch 对应的字段值发生变化时，effect 会被调用一次。

```jsx
<Form>
  <FormItem name="prov" />
  <FormItem name="cities" />
  <Form.Effect
    // 每当 prov 变化时，cities 都会被清空
    watch="prov"
    effect={(value, { model }) => {
      model.setValue('cities', []);
    }}
  />
</Form>
```

xform 将联动设计为「普通的 React 组件」，方便上层对联动进行组合和封装：

```jsx
// 组合多个 form effect 来实现表单整体的联动需求
<Form>
  <Form.Effect watch={prov} effect={() => {}} />
  <Form.Effect watch={cityDataSource$} effect={(cityList) => {}} />
  <Form.Effect watch={cities} effect={(cities) => {}} />
  {/* 更多 effect... */}
</Form>
```

```jsx
// 封装为自定义的 effect 组件
const AutoCleanEffect = ({ trigger, target }) => (
  <Form.Effect
    watch={trigger}
    effect={() => {
      target.value = null;
    }}
  />
);

// 每当省份发生变化时，自动清空城市字段
<AutoCleanEffect trigger={prov} target={cities} />;
```

针对异步数据源的场景，xform 参考了 [recoil async selector](https://recoiljs.org/docs/api-reference/core/selector#asynchronous-selectors) 设计，提供了 createAsyncValue，允许开发者使用同步的代码来描述一个异步函数的返回结果，非常适合抽象表单中的异步下拉数据源，具体详见 [xform 联动](effects#异步数据源).

## 字段模型

model.values 只记录了表单内各个字段的值，但在实际使用过程中，每个表单字段中还要包含很多状态：

- error 字段上的错误信息
- disabled 字段是否被禁用
- visible 字段是否可见
- dataSource 字段的数据源（一般用于下拉选择器）
- ...

不同的 UI 控件会带来不同的状态，我们很难在内核中枚举出所有可能的状态。其他的表单方案往往会给出一套预先定义好的状态（例如 [formily](https://github.com/alibaba/formily/blob/d772523574bda50a9ecf42e92ca6f17a0f4a6422/packages/core/src/models/Field.ts#L121-L146)），来满足绝大部分情况。

而 xform core 采用了另一种方式：**xform core 不定义预设的状态，而是只提供状态的容器**，容器内具体放什么状态由上层决定（一般是在组件库对接 xform core 的时候进行决定）。 所以 xform 中 [字段对象](api#field) 仅包含一些必要的属性和方法，整个模型非常轻量，学习成本很低 🤓。

xform 支持 field 对象 **按需生成： 无论在什么时候调用 `field = model.getField(name)`，总是能够获取到一个有效的 Field 对象**。获取的 Field 对象可以认为是「model.values 某个数据索引处的一个指针」，对 field.value 的读写会自动转换为「对 models.values 指定数据索引下的读写」。 开发者可以放心的对 field.value 进行读取与赋值，或是创建监听与联动，而不需要担心「Cannot read/set property 'xxx' of null」。

## 分形

~~优雅的表单套娃。~~

在表单复用与表单相互嵌入的场景下，一个「分形」的表单系统可以极大提升代码的可复用性。所谓「分形」，指的是「每一个表单都能被嵌入到另一个大的表单中」，分形包括「视图」和「模型」两部分。

### 视图分形

「视图分形」主要指视图代码中，表单组件总是描述 **相对数据索引**。Form.Object / Form.Array 可以包裹多个 FormItem 并指定数据索引前缀，组合形成一个独立的子表单，这个子表单又能嵌入到更上层的 Form.Object 或 Form.Array 中。具体详见 [表单片段复用示例](advanced#表单片段复用).

### 模型分形

「模型分形」指模型的数据结构和 API 是分形友好的。 xform 提供了 `model.getSubModel(name)` 方法，该方法会基于父模型返回一个子模型。 **子模型与父模型都实现了 [IModel interface](api#imodel)，两者具有相同的 API**，这意味着……

- 对 model 的操作不再需要关心 model 所处的层级
  - [即使子表单存在联动或校验，也可以直接嵌入到大表单](biz#数组元素内部联动)
- 复杂表单的拆分与合并变得更为容易
- `model.getSubModel().getSubModel()...` 可以不断地延长... 方便开发者选取合适的数据层级进行开发

同样的，xform 支持 model 对象 **按需生成： 无论在什么时候调用 `subModel = model.getModel(name)`，总是能够获取到一个有效的 Model 对象**。获取的子模型可以认为是「父模型中某个数据索引处的一个指针」，对子模型的读写会自动映射为对父模型对应数据索引的读写，确保顶层的 model.values 是整个表单的唯一可信来源。

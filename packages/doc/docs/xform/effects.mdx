---
id: effects
title: xform 联动
---

import { AsyncEffect } from 'story/src/xform/2-advanced-examples.stories.tsx';
import * as bizExamples from 'story/src/xform/3-biz-examples.stories';
import * as effectsExamples from 'story/src/xform/effects-examples';

在 xform 中，表单联动主要依赖 mobx [reaction](https://mobx.js.org/reactions.html) & [computed](https://mobx.js.org/computeds.html) 这两项能力。如果你熟悉 mobx，你可以很快地上手 xform 中的联动。

在 mobx 的基础上，xform 额外提供了 Form.Effect 与 createAsyncValue，前者用于简化 reaction 的书写，后者用于处理异步数据源。

## field 写法

书写联动关系时，我们推荐使用 [`field`](api#field) 来代替 `name` 用法. field 能更好地支持 TypeScript，避免数据索引书写错误（依赖 TS 4.1 [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)）或数据类型错误。

FormItem 同时支持 name 与 field 用法：

```jsx
// name 写法
<FormItem name="prov" />;

// field 写法
const prov = model.getField('prov');
<FormItem field={prov} />;
```

Form.Effect watch 也同样支持 field：

```jsx
// name 写法
<Form.Effect
  watch="prov"
  effect={() => {
    model.setValue('cities', []);
  }}
/>;

// field 写法
const prov = model.getField('prov');
const cities = model.getField('cities');
<Form.Effect
  watch={prov}
  effect={() => {
    cities.value = [];
  }}
/>;
```

## 联动

接下来，让我们通过几个示例来学习 xform 中的联动。 下面的示例将以「省份-城市-行政区」三级级联选择为基础，介绍如何用 xform 去书写不同类型的表单联动。

### 同步计算状态

这个例子只会用到省份和城市两级，联动要求如下：

- 用户选择省份后，展示城市下拉框；
- 切换省份时，城市下拉框需要切换为相应的数据源（数据源可以被同步获取）

对于这类 **可以被同步计算的状态**，我们 **使用 mobx computed 或直接在 react render 函数中书写计算关系**：

```jsx
const prov = model1.getField('prov');
const cities = model1.getField('cities');

<Form>
  {/* 直接使用 && 表示「省份字段非空时，渲染城市下拉框」*/}
  {prov.value && (
    <FormItem
      component="multiSelect"
      label="城市(多选)"
      field={cities}
      componentProps={{
        hasClear: true,
        // 直接计算并设置城市数据源
        dataSource: ALL_CITIES.find((item) => item.prov === prov.value).cities,
      }}
    />
  )}
</Form>;
```

实际示例如下：

<Story fn={effectsExamples.Example1} />

### 同步状态修改

在上面例子的基础上，我们添加一个新的联动要求：

- 每当省份切换时，清空城市选择

对于这类 **「当 A 字段的值发生变化时，更新 B 字段的值」** 的联动，我们需要用到 [`<Form.Effect />`](api#formeffect) 组件：

```jsx
const prov = model2.getField('prov');
const cities = model2.getField('cities');

<Form.Effect
  watch={prov}
  effect={() => {
    cities.value = [];
  }}
/>;
```

实际示例如下：

<Story fn={effectsExamples.Example2} />

:::note
`<Form.Effect />` 不仅支持 field，还支持 string、asyncValue、数组以及自定义函数，具体用法详见 [API](api#formeffect)。除了修改另一个字段的值，你也可以在 effect 中执行任意的副作用，例如发起一个数据请求。
:::

:::tip Effect 的组合
`<Form.Effect />` 被设计为普通的 React 组件用法，意味着你可以像普通组件一样对 Form.Effect 进行封装：

```jsx
const AutoCleanEffect = ({ trigger, target }) => (
  <Form.Effect
    watch={trigger}
    effect={() => {
      target.value = null;
    }}
  />
);

// 每当省份发生变化时，自动清空城市字段
<AutoCleanEffect trigger={prov} target={cities} />;
```

:::

### 异步数据源

考虑在很多实际业务中，子级下拉框的数据源来自于异步接口。这个例子中的表单联动需求变为：

- 切换省份时，城市下拉框需要切换为相应的数据源
- 城市数据源需要异步加载，加载过程中添加 loading 效果

我们可以通过 [`createAsyncValue`](api#createasyncvalue) 来创建异步数据源：

```jsx
const model3 = new FormModel({ prov: '浙江', cities: [] });
const prov = model3.getField('prov');

const cityDataSource$ = createAsyncValue(async () => {
  return fetchCityDataSourceByProvince(prov.value);
}, []);

<FormItem
  component="multiSelect"
  label="城市(多选)"
  field={cities}
  help={cityDataSource$.status === 'loading' ? 'loading...' : ''}
  componentProps={{
    hasClear: true,
    dataSource: cityDataSource$.current,
  }}
/>;
```

`createAsyncValue` 会根据参数 fetcher 创建出一个 [`AsyncValue`](api#asyncvalue) 对象，当 `asyncValue.current` 被订阅时，fetcher 将被调用，其返回结果将作为 `asyncValue.current` 的值，而 `asyncValue.status` 会记录目前异步数据的加载状态（loading / ready / error)。

在 fetcher 的**同步代码**执行过程中，mobx 会进行[依赖收集](https://mobx.js.org/understanding-reactivity.html)，每当其中的依赖发生变化时，fetcher 将会被重新执行，以使用最新的参数去获取异步数据。

实际示例如下：

<Story fn={effectsExamples.Example3} />

:::info
xform createAsyncValue 参考了 [recoil async selector](https://recoiljs.org/docs/api-reference/core/selector#asynchronous-selectors)。 允许开发者使用同步的代码来描述一个异步函数的返回结果，非常适合抽象表单中的异步下拉数据源。
:::

:::tip
Form.Effect 支持 watch 异步数据源：每当异步数据源加载完成时，effect 都会被调用一次。
:::

### 复杂联动

灵活组合上述例子中的用法，我们可以实现非常复杂的表单联动。 这次的例子用到了「省份-城市-行政区」三级级联选择，具体规则如下：

- 切换「省份」时，清空城市
- 切换城市时，移除不合理的值
- 城市和行政区均为异步数据源
- 切换城市时，移除无效的行政区

<Story fn={AsyncEffect} />

采用 `Form.Effect` 来描述每个独立的联动规则，组合多个 Form.Effect 实现整体表单联动需求。 通过这种「搭积木」的方式，我们能够在不修改已有的 FormItem 代码的基础上，一步一步地实现复杂的表单联动，并始终保持代码的可读性。

```jsx
const model = new FormModel(initValues);
const prov = model3.getField('prov');
const cityDataSource$ = createAsyncValue(async () => {});
const districtDataSource$ = createAsyncValue(async () => {});

<Form>
  <FormItem name="prov" />
  <FormItem name="cities" />
  <FormItem name="districts" />
  {/* 需要新的表单项时，将新的 FormItem 添加在这里 */}

  {/* 切换「省份」时，清空城市 */}
  <Form.Effect watch={prov} effect={() => {}} />

  {/* 城市列表加载完成时，自动设置为第一个城市 */}
  <Form.Effect watch={cityDataSource$} effect={(cityList) => {}} />

  {/* 切换城市时，移除无效的行政区 */}
  <Form.Effect watch={cities} effect={(cities) => {}} />

  {/* 需要新的联动时，将新的 Form.Effect 添加在这里 */}
</Form>;
```

### 指定作用域内的联动

大部分的联动都发生在顶层，但 xform 的分形设计使得联动也能发生在某个 model 内。

下面是一个「数组元素内部互相联动」的例子：每个数组元素中的 checkbox 控制 input 的显示或隐藏。

<Story fn={bizExamples.VisibilityControlInArrayItem} />

(todo 没有找到更好的例子，同时局部联动也不常见，文档就先这样吧)
